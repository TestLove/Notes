## 内存分布

> ![image-20201026211454427](https://raw.githubusercontent.com/TestLove/Pictures/main/img/image-20201026194915597.png)

## 垃圾回收

### **如何确定对象是否死亡**

> 从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接垃圾收集”

#### 引用计数算法

> 在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的

##### 优点

- 原理简单
- 判定效率高

##### 缺点

- 有许多例外情况
  - 循环依赖(象objA和objB都有字段instance，赋值令objA．instance=objB及objB．instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们)
  - 多线程竞争
- 需要额外的内存空间

#### 可达性分析算法

> 这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。
>
> ![来张图吧](https://raw.githubusercontent.com/TestLove/Pictures/main/img/image-20201026194915597.png)

##### 可做GCRoot的对象

- 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。·
- 在==方法区中类静态属性引用的对象==，譬如Java类的引用类型静态变量。·
- 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
- ·在本地方法栈中==JNI==（即通常所说的Native方法）引用的对象。
- ·Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。·所有被同步锁（synchronized关键字）持有的对象。·
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

#### **引用的分类**

* 强引用: 符合传统引用概念
* 软引用: 描述一些有用但不是必须的对象,内存不够时回收
* 弱引用:和软引用类似,但更弱一些,在下一次gc时回收
* 虚引用:目的只是为了能在对象被收集器回收时收到一个通知

#### 从引用对对象的访问

- 如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。

- 如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销

#### 死亡的过程

> 要经历两次标记过程：如果对象在进行可达性分析后发现==没有与GC Roots相连接的引用链==，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。

`finalize()`方法只被调用一次,调用条件:被覆盖和未被虚拟机调用

但是官方不推荐使用`finalize()`!它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序

### 回收方法区

> 方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型,方法区垃圾收集的“性价比”通常也是比较低的

- 废弃的常量
  - 已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。
  - 在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池
- 不再使用的类型
  - ·该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。·
  - 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。
  - ·该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 垃圾收集算法

> 主要是跟踪式

#### 分代收集理论